from blog_writer.utils.text import load_json


def test_load_json():
    data = """
    ```json
{
    "is_ok": true,
    "suggestions": {
        "code_snippets": [
            {
                "code": "import pandas as pd\nfrom memory_profiler import profile\n\n@profile\ndef load_data():\n    df = pd.read_csv('large_dataset.csv')\n    return df\n\nif __name__ == '__main__':\n    df = load_data()",
                "description": "Added a main guard to ensure the script runs correctly when imported."
            },
            {
                "code": "import pandas as pd\nfrom line_profiler import LineProfiler\n\n@profile\ndef process_data(df):\n    df['C'] = df['A'] + df['B']\n    df['D'] = df['C'] * 2\n    return df\n\nif __name__ == '__main__':\n    lp = LineProfiler()\n    lp_wrapper = lp(process_data)\n    df = pd.DataFrame({'A': range(1000), 'B': range(1000)})\n    lp_wrapper(df)\n    lp.print_stats()",
                "description": "Added a main guard and a profile decorator for better readability and execution."
            },
            {
                "code": "import pandas as pd\nimport pandas_profiling\n\nif __name__ == '__main__':\n    df = pd.read_csv('large_dataset.csv')\n    profile = df.profile_report(title=\"Pandas Profiling Report\")\n    profile.to_file(\"output.html\")",
                "description": "Added a main guard to ensure the script runs correctly when imported."
            },
            {
                "code": "import pandas as pd\nimport timeit\n\nsetup = '''\nimport pandas as pd\ndf = pd.DataFrame({'A': range(1000), 'B': range(1000)})\n'''\n\nstmt = '''\ndf['C'] = df['A'] + df['B']\n'''\n\nif __name__ == '__main__':\n    execution_time = timeit.timeit(stmt, setup=setup, number=1000)\n    print(f\"Average execution time: {execution_time / 1000} seconds\")",
                "description": "Added a main guard to ensure the script runs correctly when imported."
            },
            {
                "code": "import pandas as pd\nimport cProfile\n\nif __name__ == '__main__':\n    def process_data(df):\n        df['C'] = df['A'] + df['B']\n        df['D'] = df['C'] * 2\n        return df\n\n    df = pd.DataFrame({'A': range(1000), 'B': range(1000)})\n    cProfile.run('process_data(df)')",
                "description": "Added a main guard to ensure the script runs correctly when imported."
            }
        ],
        "images": [
            {
                "image": "https://example.com/memory_profiler_output.png",
                "description": "An example of the output generated by memory_profiler, showcasing memory usage line-by-line."
            },
            {
                "image": "https://example.com/line_profiler_output.png",
                "description": "A screenshot of the output generated by line_profiler, detailing the execution time for each line of code."
            },
            {
                "image": "https://example.com/pandas_profiling_report.png",
                "description": "An example of a Pandas Profiling Report, highlighting various statistics and insights about the dataset."
            },
            {
                "image": "https://example.com/cProfile_output.png",
                "description": "A screenshot of the output generated by cProfile, showing the time spent in each function."
            },
            {
                "image": "https://example.com/py_spy_output.png",
                "description": "A live view of the top functions consuming CPU time as displayed by py-spy."
            }
        ],
        "diagrams": [
            {
                "diagram": "sequenceDiagram\n    participant User\n    participant Script\n    participant Profiler\n    User->>Script: Run script\n    Script->>Profiler: Profile memory usage\n    Profiler-->>Script: Return memory usage report\n    Script-->>User: Display report",
                "description": "A sequence diagram illustrating the interaction between the user, the script, and the memory profiler."
            },
            {
                "diagram": "sequenceDiagram\n    participant User\n    participant Script\n    participant Profiler\n    User->>Script: Run script\n    Script->>Profiler: Profile execution time\n    Profiler-->>Script: Return execution time report\n    Script-->>User: Display report",
                "description": "A sequence diagram illustrating the interaction between the user, the script, and the line profiler."
            },
            {
                "diagram": "sequenceDiagram\n    participant User\n    participant Script\n    participant Profiler\n    User->>Script: Run script\n    Script->>Profiler: Generate profiling report\n    Profiler-->>Script: Return profiling report\n    Script-->>User: Display report",
                "description": "A sequence diagram illustrating the interaction between the user, the script, and the pandas-profiling tool."
            },
            {
                "diagram": "sequenceDiagram\n    participant User\n    participant Script\n    participant Profiler\n    User->>Script: Run script\n    Script->>Profiler: Profile function execution\n    Profiler-->>Script: Return function execution report\n    Script-->>User: Display report",
                "description": "A sequence diagram illustrating the interaction between the user, the script, and cProfile."
            },
            {
                "diagram": "sequenceDiagram\n    participant User\n    participant py-spy\n    User->>py-spy: Run py-spy\n    py-spy->>Running Process: Attach to process\n    Running Process-->>py-spy: Provide CPU usage data\n    py-spy-->>User: Display top functions consuming CPU time",
                "description": "A sequence diagram illustrating the interaction between the user, py-spy, and a running Python process."
            }
        ]
    }
}
```
"""

    result = load_json(data, True)
    assert result is not None


def test_load_json_2():
    data = """
{
  "title": "Mastering Memory Optimization for Pandas DataFrames",
  "description": "This article is a comprehensive guide on memory optimization techniques for Pandas DataFrames, aimed at helping data scientists and analysts efficiently manage large datasets. It begins with an introduction to the importance of memory optimization, highlighting common challenges and the need for efficient data processing. The article then delves into understanding memory usage in Pandas, providing methods to analyze and identify memory bottlenecks. It covers data type optimization, demonstrating how converting data types can significantly reduce memory usage. The use of efficient data structures, such as `Categorical` data and sparse data structures, is discussed to further minimize memory footprint. The concept of chunking large datasets is explained, showing how to process data in smaller, manageable chunks. Practical examples and case studies illustrate the real-world application and impact of these techniques. The article concludes with a summary of key points and best practices, offering a quick reference guide for future projects. This guide is designed to be accessible to readers with varying levels of expertise, providing actionable insights to optimize memory usage in Pandas DataFrames."
}
"""
    result = load_json(data, True)
    assert result is not None
